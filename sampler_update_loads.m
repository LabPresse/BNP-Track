function loads = sampler_update_loads( ...
        loads, ...
        x, ...
        y, ...
        z, ...
        bkndflux, ...
        emisrate, ...
        gain, ...
        params ...
    )

    emitter_contr = zeros(params.P, params.N, params.M);

    for m = 1:params.M

        for k = 1:params.K
            % params.ak saves the unitless coefficients of the composite trapezoidal quadrature
            emitter_contr(:, :, m) = emitter_contr(:, :, m) + reshape( ...
            params.ak(k) * get_g_PSF_weiqing( ...
                x(params.t_idx(:, k), m), ...
                y(params.t_idx(:, k), m), ...
                z(params.t_idx(:, k), m), ...
                params.x_bnd, ...
                params.y_bnd, ...
                params.PSF_params), params.P, params.N, 1);
        end

    end

    % params.dt_exp is the exposure time
    emitter_contr = params.dt_exp / params.f * emisrate * emitter_contr;

    bknd_contr = params.dt_exp / params.f * bkndflux * params.px_area_col;

    log_signal = params.w_cnt_log - log(gain);

    log_post = [0; 0];

    log_prior = [log(params.M - 1); log(params.bm_prior_gamma)];
    %%
    for m = 1:params.M

        % Compute the likelihood from particles other than m
        not_m = [1:m - 1, m + 1:params.M];

        m_off = bknd_contr + sum(permute(loads(not_m), [1, 3, 2]) .* emitter_contr(:, :, not_m), 3);
        log_post(1) = sum(m_off .* log_signal - gammaln(m_off), 'all');
        m_on = m_off + emitter_contr(:, :, m);
        log_post(2) = sum(m_on .* log_signal - gammaln(m_on), 'all');

        log_post = log_post + log_prior;
        log_post = log_post - max(log_post);

        [~, result] = max(log_post - log(-log(rand(2, 1))));

        if result == 2
            loads(m) = true;
            %{
            for m2 = not_m(randperm(exp(log_prior(1))))
                [loads(m), loads(m2)] = joint_update_loads( ...
                    loads(m2), ...
                    m_on, ...
                    m_off, ...
                    emitter_contr(:, :, m2), ...
                    log_signal, ...
                    log_prior ...
                );
            end
            %}

        else
            loads(m) = false;
        end

    end

end

function [load1, load2] = joint_update_loads( ...
        load2, ...
        one_on, ...
        one_off, ...
        contr_two, ...
        log_signal, ...
        log_prior ...
    )

    if load2
        [load1, load2] = joint_sampler( ...
            one_on - contr_two, ...
            one_off, ...
            one_on, ...
            one_off - contr_two, ...
            log_signal, ...
            log_prior ...
        );
    else
        [load1, load2] = joint_sampler( ...
            only1, ...
            one_off + contr_two, ...
            one_on + contr_two, ...
            neither, ...
            log_signal, ...
            log_prior ...
        );
    end

    switch k
        case 1
            load1 = false;
        case 2
            load1 = true;
        case 3
            load1 = false;
            load2 = ~load2;
            one_off = vpn_3;
        case 4
            loads(mA) = true;
            loads(m2) = ~loads(m2);
            one_off = vpn_3;
    end

end

function [load1, load2] = joint_sampler( ...
        only1, ...
        only2, ...
        both, ...
        neither, ...
        log_signal, ...
        log_prior ...
    )

    [~, k] = max( ...
        [ ...
            sum(only1 .* log_signal - gammaln(only1), 'all') + log_prior(2) + log_prior(1); ...
            sum(only2 .* log_signal - gammaln(only2), 'all') + log_prior(1) + log_prior(2); ...
            sum(neither .* log_signal - gammaln(neither), 'all') + 2 * log_prior(1); ...
            sum(both .* log_signal - gammaln(both), 'all') + 2 * log_prior(2) ...
        ] - log(-log(rand(4, 1))) ...
    );

    switch k
        case 1
            load1 = true;
            load2 = false;
        case 2
            load1 = false;
            load2 = true;
        case 3
            load1 = false;
            load2 = false;
        case 4
            load1 = true;
            load2 = true;
    end

end

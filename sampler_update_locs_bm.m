function [activeX, activeY, activeZ, D, rec] = sampler_update_locs_bm( ...
        active_num, ...
        activeX, ...
        activeY, ...
        activeZ, ...
        bkndflux, ...
        emisrate, ...
        gain, ...
        rec, ...
        T, ...
        params)

    %% then update bright segments
    get_X_propos = @(b)params.MH_sc(4) ...
    * params.PSF_params.s_ref ...
        * randn(params.K, b);
    get_Y_propos = @(b)params.MH_sc(4) ...
        * params.PSF_params.s_ref ...
        * randn(params.K, b);
    get_Z_propos = @(b)params.MH_sc(4) ...
        * params.PSF_params.z_ref ...
        * randn(params.K, b);

    get_X_PROPOS = @(b) params.MH_sc(5) ...
        * params.PSF_params.s_ref ...
        * randn(params.K, b) ...
        .* double(rand(params.K, b) <= 1 / (params.K * b));
    get_Y_PROPOS = @(b) params.MH_sc(5) ...
        * params.PSF_params.s_ref ...
        * randn(params.K, b) ...
        .* double(rand(params.K, b) <= 1 / (params.K * b));
    get_Z_PROPOS = @(b) params.MH_sc(5) ...
        * params.PSF_params.z_ref ...
        * randn(params.K, b) ...
        .* double(rand(params.K, b) <= 1 / (params.K * b));

    W = log(params.w_cnt / (params.f * gain));

    sample_vp = nan(params.Px, params.Py, params.N);
    sample_P = nan(params.N, 1);

    for n = 1:params.N
        sample_vp(:, :, n) = get_image( ...
            1:active_num, ...
            activeX(params.t_idx(n, :), :), ...
            activeY(params.t_idx(n, :), :), ...
            activeZ(params.t_idx(n, :), :), ...
            params.ak, ...
            params.x_bnd, ...
            params.y_bnd, ...
            params.dt_exp / params.f, ...
            bkndflux, ...
            emisrate, ...
            params.PSF_params ...
        );
        sample_P(n) = sum( ...
            sample_vp(:, :, n) .* W(:, :, n) - gammaln(sample_vp(:, :, n)), ...
            'all' ...
        );
    end

    AD = params.D_prior_phi + 1.5 * active_num * (params.N * params.K - 1);
    sample_inv_BD = params.D_prior_phi * params.D_prior_chi ...
        + 0.25 * sum( ...
        sum(diff(activeX).^2 + diff(activeY).^2 + diff(activeZ).^2, 2) ./ diff(params.t_mid) ...
    );

    for rep = 1:30

        for n = randperm(params.N)

            % localization proposals
            propos_Xm_n_bm = activeX(params.t_idx(n, :), :) + get_X_propos(active_num);
            propos_Ym_n_bm = activeY(params.t_idx(n, :), :) + get_Y_propos(active_num);
            propos_Zm_n_bm = activeZ(params.t_idx(n, :), :) + get_Z_propos(active_num);

            propos_vp_n = get_image( ...
                [], ...
                propos_Xm_n_bm, ...
                propos_Ym_n_bm, ...
                propos_Zm_n_bm, ...
                params.ak, ...
                params.x_bnd, ...
                params.y_bnd, ...
                params.dt_exp / params.f, ...
                bkndflux, ...
                emisrate, ...
                params.PSF_params ...
            );
            propos_P_n = sum(propos_vp_n .* W(:, :, n) - gammaln(propos_vp_n), 'all');

            log_a = (propos_P_n - sample_P(n)) / T;

            switch n
                case 1
                    idx = 1:params.t_idx(n + 1, 1);
                    pos = 'start';
                    log_a = log_a + 0.5 * sum( ...
                        ((activeX(1, :) - params.Xm_prior_mu).^2 - (propos_Xm_n_bm(1, :) - params.Xm_prior_mu).^2) / params.Xm_prior_sg^2 ...
                        + ((activeY(1, :) - params.Ym_prior_mu).^2 - (propos_Ym_n_bm(1, :) - params.Ym_prior_mu).^2) / params.Ym_prior_sg^2 ...
                        + ((activeZ(1, :) - params.Zm_prior_mu).^2 - (propos_Zm_n_bm(1, :) - params.Zm_prior_mu).^2) / params.Zm_prior_sg^2 ...
                    );
                case params.N
                    idx = params.t_idx(n - 1, end):params.N * params.K;
                    pos = 'end';
                otherwise
                    idx = params.t_idx(n - 1, end):params.t_idx(n + 1, 1);
                    pos = 'mid';
            end

            propos_inv_BD = sample_inv_BD + delta_inv_BD( ...
                activeX(idx, :), ...
                activeY(idx, :), ...
                activeZ(idx, :), ...
                propos_Xm_n_bm, ...
                propos_Ym_n_bm, ...
                propos_Zm_n_bm, ...
                params.t_mid(idx), ...
                pos ... ...
            );

            log_a = log_a + AD * log(sample_inv_BD / propos_inv_BD);

            if log(rand) < log_a
                activeX(params.t_idx(n, :), :) = propos_Xm_n_bm;
                activeY(params.t_idx(n, :), :) = propos_Ym_n_bm;
                activeZ(params.t_idx(n, :), :) = propos_Zm_n_bm;
                sample_vp(:, :, n) = propos_vp_n;
                sample_P(n) = propos_P_n;
                sample_inv_BD = propos_inv_BD;
                rec(1, 1) = rec(1, 1) + 1;
            end

            rec(2, 1) = rec(2, 1) + 1;

            % localization proposals
            propos_Xm_n_bm = activeX(params.t_idx(n, :), :) + get_X_PROPOS(active_num);
            propos_Ym_n_bm = activeY(params.t_idx(n, :), :) + get_Y_PROPOS(active_num);
            propos_Zm_n_bm = activeZ(params.t_idx(n, :), :) + get_Z_PROPOS(active_num);

            propos_vp_n = get_image( ...
                [], ...
                propos_Xm_n_bm, ...
                propos_Ym_n_bm, ...
                propos_Zm_n_bm, ...
                params.ak, ...
                params.x_bnd, ...
                params.y_bnd, ...
                params.dt_exp / params.f, ...
                bkndflux, ...
                emisrate, ...
                params.PSF_params);
            propos_P_n = sum(propos_vp_n .* W(:, :, n) - gammaln(propos_vp_n), 'all');

            log_a = (propos_P_n - sample_P(n)) / T;

            switch n
                case 1
                    idx = 1:params.t_idx(n + 1, 1);
                    pos = 'start';
                    log_a = log_a + 0.5 * sum( ...
                        ((activeX(1, :) - params.Xm_prior_mu).^2 - (propos_Xm_n_bm(1, :) - params.Xm_prior_mu).^2) / params.Xm_prior_sg^2 ...
                        + ((activeY(1, :) - params.Ym_prior_mu).^2 - (propos_Ym_n_bm(1, :) - params.Ym_prior_mu).^2) / params.Ym_prior_sg^2 ...
                        + ((activeZ(1, :) - params.Zm_prior_mu).^2 - (propos_Zm_n_bm(1, :) - params.Zm_prior_mu).^2) / params.Zm_prior_sg^2 ...
                    );
                case params.N
                    idx = params.t_idx(n - 1, end):params.N * params.K;
                    pos = 'end';
                otherwise
                    idx = params.t_idx(n - 1, end):params.t_idx(n + 1, 1);
                    pos = 'mid';
            end

            propos_inv_BD = sample_inv_BD + delta_inv_BD( ...
                activeX(idx, :), ...
                activeY(idx, :), ...
                activeZ(idx, :), ...
                propos_Xm_n_bm, ...
                propos_Ym_n_bm, ...
                propos_Zm_n_bm, ...
                params.t_mid(idx), ...
                pos ...
            );

            log_a = log_a + AD * log(sample_inv_BD / propos_inv_BD);

            if log(rand) < log_a
                activeX(params.t_idx(n, :), :) = propos_Xm_n_bm;
                activeY(params.t_idx(n, :), :) = propos_Ym_n_bm;
                activeZ(params.t_idx(n, :), :) = propos_Zm_n_bm;
                sample_vp(:, :, n) = propos_vp_n;
                sample_P(n) = propos_P_n;
                sample_inv_BD = propos_inv_BD;
                rec(1, 2) = rec(1, 2) + 1;
            end

            rec(2, 2) = rec(2, 2) + 1;

        end

    end

    D = sampler_update_D(active_num, activeX, activeY, activeZ, params);

end

function r = delta_inv_BD( ...
        activeX, ...
        activeY, ...
        activeZ, ...
        propos_Xm_n_bm, ...
        propos_Ym_n_bm, ...
        propos_Zm_n_bm, ...
        t_mid, ...
        pos ...
    )
    r = 0.25 * sum( ...
        sum( ...
        get_diff(activeX, propos_Xm_n_bm, pos) ...
        + get_diff(activeY, propos_Ym_n_bm, pos) ...
        + get_diff(activeZ, propos_Zm_n_bm, pos), ...
        2 ...
    ) ./ diff(t_mid) ...
    );

end

function r = get_diff(old_traj, prop_segment, pos)

    switch pos
        case 'start'
            r = diff([prop_segment; old_traj(end, :)]);
        case 'end'
            r = diff([old_traj(1, :); prop_segment]);
        case 'mid'
            r = diff([old_traj(1, :); prop_segment; old_traj(end, :)]);
        otherwise
            error('Unknown position')
    end

    r = r.^2 - diff(old_traj).^2;

end
